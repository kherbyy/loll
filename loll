if not game:IsLoaded() then
    game.Loaded:Wait()
end

-- Load the Rayfield UI Library
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

-- Create the standalone window
local Window = Rayfield:CreateWindow({
    Name = "Index-Style Aimbot, Silent Aim, Combat & Desync System",
    LoadingTitle = "Loading Complete System",
    LoadingSubtitle = "Loading...",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "IndexCombatSystem",
        FileName = "Config"
    },
    KeySystem = false
})

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local Workspace = game:GetService("Workspace")
local Camera = workspace.CurrentCamera
local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()

-- Modules & Remotes (Combat System)
local Remote = ReplicatedStorage:WaitForChild("Remote")
local GunHandler = require(ReplicatedStorage.Modules.Guns.GunHandler)
local Configuration = require(ReplicatedStorage.Modules.Guns.Configuration)
local RemoteFunction = require(ReplicatedStorage.RemoteFunction)
local Controller = require(ReplicatedStorage.Modules.Controller)

-- Local Player Root
local Root = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")

-- Create tabs
local MainTab = Window:CreateTab("Main", nil)
local CombatTab = Window:CreateTab("Combat", nil)
local DesyncTab = Window:CreateTab("Desync", nil)
local MenuTab = Window:CreateTab("Menu", nil)
local ShopTab = Window:CreateTab("Shop", nil)

-- ==================================================
-- DESYNC SYSTEM VARIABLES
-- ==================================================

-- Desync Variables
getgenv().Desync = {
    Enabled = false,
    Method = "Void",
    AutoDesyncOnDamage = true,
    HealthThreshold = 90,
    LastHealth = 100,
    Cooldown = 1,
    LastTriggered = 0
}

local DesyncData = {
    OriginalCFrame = CFrame.new(),
    StartTime = tick(),
}

local DesyncMethods = {
    Void = function(RootPart)
        RootPart.CFrame = CFrame.new(math.sqrt(-1), math.sqrt(-1), math.sqrt(-1))
        RunService.RenderStepped:Wait()
        RootPart.CFrame = DesyncData.OriginalCFrame
    end,

    Sky = function(RootPart)
        RootPart.CFrame = DesyncData.OriginalCFrame * CFrame.new(0, 100000, 0)
        RunService.RenderStepped:Wait()
        RootPart.CFrame = DesyncData.OriginalCFrame
    end,

    Underground = function(RootPart)
        RootPart.CFrame = DesyncData.OriginalCFrame * CFrame.new(0, -10000, 0)
        RunService.RenderStepped:Wait()
        RootPart.CFrame = DesyncData.OriginalCFrame
    end,

    Random = function(RootPart)
        local RandX = math.random(-100, 100)
        local RandY = math.random(-100, 100)
        local RandZ = math.random(-100, 100)

        RootPart.CFrame = DesyncData.OriginalCFrame * CFrame.new(RandX, RandY, RandZ)
        RunService.RenderStepped:Wait()
        RootPart.CFrame = DesyncData.OriginalCFrame
    end,

    Oscillate = function(RootPart)
        local ElapsedTime = tick() - DesyncData.StartTime
        local Distance = math.sin(ElapsedTime * 5) * 50

        RootPart.CFrame = DesyncData.OriginalCFrame * CFrame.new(0, Distance, 0)
        RunService.RenderStepped:Wait()
        RootPart.CFrame = DesyncData.OriginalCFrame
    end,

    Spin = function(RootPart)
        local ElapsedTime = tick() - DesyncData.StartTime
        local Angle = ElapsedTime * 20

        RootPart.CFrame = DesyncData.OriginalCFrame * CFrame.Angles(0, Angle, 0)
        RunService.RenderStepped:Wait()
        RootPart.CFrame = DesyncData.OriginalCFrame
    end,
}

-- Void Spam Desync Variables
getgenv().VoidSpam = {
    Enabled = false,
    Method = "Void",
    BreakVelocity = false,
    SpamKeybind = Enum.KeyCode.X
}

local ShouldInVoid = false
local VoidDataPos = nil

-- Void Spam Methods
local VoidSpamMethods = {
    Void = function(RootPart)
        RootPart.CFrame = CFrame.new(0/0, 0/0, 0/0)
        RunService.RenderStepped:Wait()
        RootPart.CFrame = VoidDataPos
    end,

    Underworld = function(RootPart)
        RootPart.CFrame = CFrame.new(RootPart.Position.X, workspace.FallenPartsDestroyHeight - 100, RootPart.Position.Z)
        RunService.RenderStepped:Wait()
        RootPart.CFrame = VoidDataPos
    end,

    Random = function(RootPart)
        RootPart.CFrame = CFrame.new(math.random(-100, 100), math.random(-100, 100), math.random(-100, 100))
        RunService.RenderStepped:Wait()
        RootPart.CFrame = VoidDataPos
    end,

    Sky = function(RootPart)
        RootPart.CFrame = CFrame.new(RootPart.Position.X, 100000, RootPart.Position.Z)
        RunService.RenderStepped:Wait()
        RootPart.CFrame = VoidDataPos
    end,

    Nan = function(RootPart)
        RootPart.CFrame = CFrame.new(math.sqrt(-1), math.sqrt(-1), math.sqrt(-1))
        RunService.RenderStepped:Wait()
        RootPart.CFrame = VoidDataPos
    end
}

-- ==================================================
-- DESYNC FUNCTIONS
-- ==================================================

local function LocalTriggerDesyncOnce()
    local LocalCharacter = LP.Character
    local LocalRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
    if not LocalRootPart then return end

    DesyncData.OriginalCFrame = LocalRootPart.CFrame
    DesyncData.StartTime = tick()

    local SelectedMethodName = getgenv().Desync.Method
    local MethodToCall = DesyncMethods[SelectedMethodName]

    if MethodToCall then
        MethodToCall(LocalRootPart)
    end

    getgenv().Desync.LastTriggered = tick()
end

if getgenv().Desync then
    getgenv().Desync.TriggerOnce = LocalTriggerDesyncOnce
else
    warn("Desyncronization.lua: getgenv().Desync not found when attempting to assign TriggerOnce.")
end

-- Void Spam Break Velocity Function
local function VoidBreakVelocity()
    if LP.Character then
        for _, Part in ipairs(LP.Character:GetDescendants()) do
            if Part:IsA("BasePart") then
                Part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                Part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
            end
        end
    end
end

local function checkHealth()
    local character = LP.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local currentHealth = humanoid.Health
    local maxHealth = humanoid.MaxHealth
    local healthPercent = (currentHealth / maxHealth) * 100
    local desync = getgenv().Desync

    if desync.AutoDesyncOnDamage and healthPercent < desync.HealthThreshold and
       desync.LastHealth > healthPercent and
       (tick() - desync.LastTriggered) > desync.Cooldown then

        LocalTriggerDesyncOnce()
    end

    desync.LastHealth = healthPercent
end

-- Desync Loop
coroutine.wrap(function()
    RunService.Heartbeat:Connect(function()
        checkHealth()

        if getgenv().Desync.Enabled then
            local LocalCharacter = LP.Character
            local LocalRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
            if not LocalRootPart then return end

            DesyncData.OriginalCFrame = LocalRootPart.CFrame

            local SelectedMethod = getgenv().Desync.Method
            if DesyncMethods[SelectedMethod] then
                DesyncMethods[SelectedMethod](LocalRootPart)
            end
        end
    end)
end)()

-- Void Spam Loop
coroutine.wrap(function()
    while true do
        if getgenv().VoidSpam.Enabled then
            ShouldInVoid = not ShouldInVoid
        end
        
        if ShouldInVoid then
            local Character = LP.Character
            local Root = Character and Character:FindFirstChild("HumanoidRootPart")
            if Root then
                VoidDataPos = Root.CFrame
                
                local SelectedMethodName = getgenv().VoidSpam.Method
                local MethodToCall = VoidSpamMethods[SelectedMethodName]
                
                if MethodToCall then
                    MethodToCall(Root)
                end
            end
        end
        task.wait(0)
    end
end)()

-- Void Spam Break Velocity Loop
coroutine.wrap(function()
    RunService.Heartbeat:Connect(function()
        if getgenv().VoidSpam.BreakVelocity then
            VoidBreakVelocity()
        end
    end)
end)()

-- CFrame Hooks
local OriginalCFrameHook = nil
OriginalCFrameHook = hookmetamethod(game, "__index", newcclosure(function(Self, Key)
    if getgenv().Desync.Enabled then
        if not checkcaller() then
            if Key == "CFrame" and LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") and LP.Character:FindFirstChild("Humanoid") and LP.Character.Humanoid.Health > 0 then
                if Self == LP.Character.HumanoidRootPart then
                    return DesyncData.OriginalCFrame or CFrame.new()
                elseif Self == LP.Character.Head then
                    return DesyncData.OriginalCFrame or CFrame.new()
                end
            end
        end
    end
    return OriginalCFrameHook(Self, Key)
end))

local OriginalVoidCFrameHook
OriginalVoidCFrameHook = hookmetamethod(game, "__index", newcclosure(function(Self, Key)
    if ShouldInVoid and not checkcaller() and Key == "CFrame" then
        local Char = LP.Character
        if Char and Char:FindFirstChild("HumanoidRootPart") and Char:FindFirstChild("Humanoid") and Char.Humanoid.Health > 0 then
            if Self == Char.HumanoidRootPart then
                return VoidDataPos or CFrame.new()
            elseif Self == Char:FindFirstChild("Head") then
                local Root = Char.HumanoidRootPart
                return (VoidDataPos and VoidDataPos * CFrame.new(0, Root.Size.Y / 2 + 0.5, 0)) or CFrame.new()
            end
        end
    end
    return OriginalVoidCFrameHook(Self, Key)
end))

-- ==================================================
-- DESYNC TAB UI ELEMENTS
-- ==================================================

local DesyncSection = DesyncTab:CreateSection("Standard Desync")

local DesyncToggle = DesyncTab:CreateToggle({
    Name = "Desync",
    CurrentValue = false,
    Flag = "DesyncToggle",
    Callback = function(Value)
        getgenv().Desync.Enabled = Value
        StarterGui:SetCore("SendNotification", {Title = "Desync", Text = Value and "Enabled" or "Disabled", Duration = 3})
    end,
})

local DesyncMethodDropdown = DesyncTab:CreateDropdown({
    Name = "Desync Method",
    Options = {"Void", "Sky", "Underground", "Random", "Oscillate", "Spin"},
    CurrentOption = {"Void"},
    Flag = "DesyncMethodDropdown",
    Callback = function(Option)
        getgenv().Desync.Method = Option[1]
    end,
})

-- Auto Desync on Damage Toggle
local AutoDesyncToggle = DesyncTab:CreateToggle({
    Name = "Auto Desync on Damage",
    CurrentValue = true,
    Flag = "AutoDesyncToggle",
    Callback = function(Value)
        getgenv().Desync.AutoDesyncOnDamage = Value
    end,
})

-- Health Threshold Slider
local DesyncHealthThresholdSlider = DesyncTab:CreateSlider({
    Name = "Health Threshold (%)",
    Range = {1, 100},
    Increment = 1,
    Suffix = "%",
    CurrentValue = 90,
    Flag = "DesyncHealthThresholdSlider",
    Callback = function(Value)
        getgenv().Desync.HealthThreshold = Value
    end,
})

-- Cooldown Slider
local DesyncCooldownSlider = DesyncTab:CreateSlider({
    Name = "Desync Cooldown (s)",
    Range = {0.1, 5},
    Increment = 0.1,
    Suffix = "s",
    CurrentValue = 1,
    Flag = "DesyncCooldownSlider",
    Callback = function(Value)
        getgenv().Desync.Cooldown = Value
    end,
})

-- Void Spam Section
local VoidSpamSection = DesyncTab:CreateSection("Void Spam Desync")

local VoidSpamToggle = DesyncTab:CreateToggle({
    Name = "Void Spam",
    CurrentValue = false,
    Flag = "VoidSpamToggle",
    Callback = function(Value)
        getgenv().VoidSpam.Enabled = Value
        if not getgenv().VoidSpam.Enabled then
            ShouldInVoid = false
        end
        StarterGui:SetCore("SendNotification", {
            Title = "Void Spam", 
            Text = Value and "Enabled" or "Disabled", 
            Duration = 3
        })
    end,
})

local VoidSpamMethodDropdown = DesyncTab:CreateDropdown({
    Name = "Void Spam Method",
    Options = {"Void", "Underworld", "Random", "Sky", "Nan"},
    CurrentOption = {"Void"},
    Flag = "VoidSpamMethodDropdown",
    Callback = function(Option)
        getgenv().VoidSpam.Method = Option[1]
    end,
})

local VoidBreakVelocityToggle = DesyncTab:CreateToggle({
    Name = "Break Velocity (Void Spam)",
    CurrentValue = false,
    Flag = "VoidBreakVelocityToggle",
    Callback = function(Value)
        getgenv().VoidSpam.BreakVelocity = Value
        StarterGui:SetCore("SendNotification", {
            Title = "Void Break Velocity", 
            Text = Value and "Enabled" or "Disabled", 
            Duration = 3
        })
    end,
})

-- ==================================================
-- COMBAT SYSTEM VARIABLES
-- ==================================================

-- Kill All & Rapid Fire Variables
local killAllEnabled = false
local currentKillAllTarget = nil
local fireCooldown = 0.05
local lastFire = 0
local targetOnlyList = {}
local doNotTargetList = {}
local angle = 0
local radius = 10
local speed = 0.1

local allRapidEnabled = false
local whitelist = {}
local rapidBlacklist = {}
local lastFiresAll = {}
local rapidFireRate = 20

-- Bullet Rage TP Variables
local rapidEnabled = false
local lastFireTime = 0
local lastSwapTime = 0
local swapping = false
local currentTarget = nil
local FIRE_COOLDOWN = 0.22

-- Anti Stomp Variables
local antiStompEnabled = false
local autoAntiStomp = false
local lagAntiStomp = false

-- No Jump Cooldown
local noJumpCooldownEnabled = false
local noJumpConnections = {}

-- No Shooting Cooldown
local noShootingCooldownEnabled = true

-- No Walk Cooldown When Shooting
local noWalkCooldownEnabled = true

-- Anti Mod
local antiModEnabled = false
local antiModTargetUserIds = {
    9258752864, 8004978600, 434260279, 512673994,
    3790051187, 2206944767, 416004704, 5352019249,
    1487697276, 9258782554
}
local antiModConnection = nil

-- Infinite Ammo
local UNLIMITED_AMMO = 999999
local originalRaycast = GunHandler.Raycast
local infAmmoEnabled = false
local heartbeatConn = nil
local mainEvent = ReplicatedStorage:FindFirstChild("MainEvent")

-- Auto Armor Variables
local autoArmorEnabled = false
local autoArmorOnDamage = false
local armorCooldown = false
local armorPurchaseCooldown = 2
local lastArmorPurchase = 0
local healthThreshold = 50

-- Store original configuration values
local OriginalConfig = {}
for _, data in pairs(Configuration) do
    if typeof(data) == "table" then
        OriginalConfig[data] = {
            Damage = data.Damage,
            Recoil = data.Recoil,
            CameraShake = data.CameraShake,
            Knockback = data.Knockback,
            Spread = data.Spread,
            BulletSpread = data.BulletSpread,
            Accuracy = data.Accuracy,
            Cooldown = data.Cooldown,
            ReloadTime = data.ReloadTime
        }
    end
end

-- Bullet Rage TP Configuration
getgenv().BulletRageTP = {
    Enabled = false,
    Prediction = 0.14,
    ClosestPart = false,
    SwapScale = 1.4,
    SwapMin = 0.35,
    SwapMax = 0.75,
}

-- ==================================================
-- COMBAT HELPER FUNCTIONS
-- ==================================================

local function applyGunConfig()
    for key, data in pairs(Configuration) do
        if typeof(data) == "table" then
            if OriginalConfig[data] then
                data.Damage = 999
                data.Spread = 0
                data.BulletSpread = 0
                data.Accuracy = 100
                
                if noShootingCooldownEnabled then
                    data.Cooldown = 0
                    data.ReloadTime = 0
                else
                    data.Cooldown = OriginalConfig[data].Cooldown
                    data.ReloadTime = OriginalConfig[data].ReloadTime
                end
                
                if noWalkCooldownEnabled then
                    data.Recoil = 0
                    data.CameraShake = 0
                    data.Knockback = 0
                else
                    data.Recoil = OriginalConfig[data].Recoil
                    data.CameraShake = OriginalConfig[data].CameraShake
                    data.Knockback = OriginalConfig[data].Knockback
                end
            end
        end
    end
end

applyGunConfig()

local function isDowned(player)
    if not player.Character then return false end
    local state = player.Character:FindFirstChild("State")
    if not state then return false end
    local down = state:FindFirstChild("Down")
    return down and down.Value == true
end

local function isDead(player)
    if not player.Character then return true end
    local state = player.Character:FindFirstChild("State")
    if not state then return true end
    local dead = state:FindFirstChild("Dead")
    return dead and dead.Value == true
end

local function isAlive(player)
    local char = player.Character
    if not char then return false end
    local hum = char:FindFirstChild("Humanoid")
    local state = char:FindFirstChild("State")
    if not hum or not state then return false end
    if char:FindFirstChild("ForceField") then return false end
    return hum.Health > 0 and (not state:FindFirstChild("Down") or state.Down.Value == false)
end

local function isFullyLoaded(player)
    if not player.Character then return false end
    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    local humanoid = player.Character:FindFirstChild("Humanoid")
    local state = player.Character:FindFirstChild("State")
    if not hrp or not humanoid or not state then return false end
    if hrp.AssemblyLinearVelocity.Magnitude > 1000 then return false end
    return player.Character:FindFirstChild("FULLY_LOADED_CHAR") or true
end

local function shouldTargetPlayer(player)
    if player == LP then return false end
    local nameLower = player.Name:lower()
    local displayLower = player.DisplayName:lower()
    local isAllowed = true

    for _, name in ipairs(doNotTargetList) do
        if nameLower:find(name:lower()) or displayLower:find(name:lower()) then
            return false
        end
    end

    if #targetOnlyList > 0 then
        isAllowed = false
        for _, name in ipairs(targetOnlyList) do
            if nameLower:find(name:lower()) or displayLower:find(name:lower()) then
                isAllowed = true
                break
            end
        end
    end

    return isAllowed
end

local function getClosestKillAllTarget(targetList)
    if not Root or #targetList == 0 then return nil end
    local closest, minDist = nil, math.huge
    local rootPos = Root.Position

    for _, player in ipairs(targetList) do
        local char = player.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local dist = (char.HumanoidRootPart.Position - rootPos).Magnitude
            if dist < minDist then
                minDist = dist
                closest = player
            end
        end
    end
    return closest
end

local function CircleAroundTarget(targetPlayer)
    local char, targetChar = LP.Character, targetPlayer.Character
    if not (char and targetChar) then return end
    local hrp, targetHRP = char:FindFirstChild("HumanoidRootPart"), targetChar:FindFirstChild("HumanoidRootPart")
    if hrp and targetHRP then
        angle = angle + speed
        local offset = Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
        hrp.CFrame = CFrame.new(targetHRP.Position + Vector3.new(0, 3, 0) + offset, targetHRP.Position)
    end
end

local function ForceHit(tool, targetPlayer)
    local char, targetChar = LP.Character, targetPlayer.Character
    if not (char and targetChar and tool and tool:FindFirstChild("Handle")) then return end
    local targetHum = targetChar:FindFirstChild("Humanoid")
    local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
    if not (targetHum and targetHRP and targetHum.Health > 0) then return end

    Remote:FireServer("ShootingNoAmmo", tool)
    if tool.Name == "Double Barrel" then
        for i = 1, 4 do
            local spreadOffset = Vector3.new(math.random(-20, 20) / 100, math.random(-20, 20) / 100, math.random(-20, 20) / 100)
            local spreadTarget = targetHRP.Position + spreadOffset
            GunHandler.Raycast(LP, tool.Handle.Position, spreadTarget, tool)
        end
    else
        GunHandler.Raycast(LP, tool.Handle.Position, targetHRP.Position, tool)
    end
    RemoteFunction:InvokeClient(LP, "Aim", tool.Handle.Position)
    Remote:FireServer("GunDamage", tool, targetChar, targetHum, 999, Vector3.zero, tool.Handle.Position, targetHRP.Position)
end

local function ShootAtTarget(tool, targetPlayer)
    local char = LP.Character
    local targetChar = targetPlayer.Character
    if not tool or not tool:FindFirstChild("Handle") then return end
    if not char or not targetChar then return end
    local targetHum = targetChar:FindFirstChild("Humanoid")
    local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
    if not (targetHum and targetHRP and targetHum.Health > 0) then return end

    Remote:FireServer("ShootingNoAmmo", tool)
    if tool.Name == "Double Barrel" then
        for i = 1, 4 do
            local spreadOffset = Vector3.new(math.random(-20, 20) / 100, math.random(-20, 20) / 100, math.random(-20, 20) / 100)
            local spreadTarget = targetHRP.Position + spreadOffset
            GunHandler.Raycast(LP, tool.Handle.Position, spreadTarget, tool)
        end
    else
        GunHandler.Raycast(LP, tool.Handle.Position, targetHRP.Position, tool)
    end
    RemoteFunction:InvokeClient(LP, "Aim", tool.Handle.Position)
    Remote:FireServer("GunDamage", tool, targetChar, targetHum, 999, Vector3.zero, tool.Handle.Position, targetHRP.Position)
end

local function getActualBody(player)
    if not player or not player.Character then return nil end
    local lowestPart, lowestY = nil, math.huge
    for _, part in ipairs(player.Character:GetChildren()) do
        if part:IsA("BasePart") and part.Position.Y < lowestY then
            lowestY = part.Position.Y
            lowestPart = part
        end
    end
    return lowestPart
end

local function StompTarget(downedTargets)
    if #downedTargets == 0 then return end

    local closestDowned, minDist = nil, math.huge
    for _, p in ipairs(downedTargets) do
        if p.Character and p.Character.PrimaryPart then
            local dist = (p.Character.PrimaryPart.Position - Root.Position).Magnitude
            if dist < minDist then
                minDist = dist
                closestDowned = p
            end
        end
    end

    if closestDowned and closestDowned.Character then
        local body = getActualBody(closestDowned)
        if body then
            Root.CFrame = CFrame.new(body.Position + Vector3.new(0, 1.5, 0))
            Remote:FireServer("Stomp", closestDowned.Character)
        end
    end
end

-- Infinite Ammo Functions
local function patchAmmo(tool)
    if not tool then return end
    local ac = tool:FindFirstChild("Ammo_CLIENT")
    if ac and type(ac.Value) == "number" then ac.Value = UNLIMITED_AMMO end
    local a = tool:FindFirstChild("Ammo")
    if a and type(a.Value) == "number" then a.Value = UNLIMITED_AMMO end
end

local function enableInfAmmo()
    if infAmmoEnabled then return end
    infAmmoEnabled = true

    GunHandler.Raycast = function(self, startPos, endPos, tool, ...)
        pcall(patchAmmo, tool)
        if mainEvent then
            pcall(function()
                mainEvent:FireServer("Shoot", tool, (endPos - startPos).Unit * 1000)
            end)
        end
        pcall(function()
            Remote:FireServer("ShootingNoAmmo", tool)
        end)
        return originalRaycast(self, startPos, endPos, tool, ...)
    end

    heartbeatConn = RunService.Heartbeat:Connect(function()
        local char = LP.Character
        if char then
            local tool = char:FindFirstChildOfClass("Tool")
            if tool then patchAmmo(tool) end
        end
        local backpack = LP:FindFirstChild("Backpack")
        if backpack then
            local children = backpack:GetChildren()
            for i = 1, #children do
                local btool = children[i]
                if btool and btool:IsA("Tool") then patchAmmo(btool) end
            end
        end
    end)
end

local function disableInfAmmo()
    if not infAmmoEnabled then return end
    infAmmoEnabled = false
    GunHandler.Raycast = originalRaycast
    if heartbeatConn then
        heartbeatConn:Disconnect()
        heartbeatConn = nil
    end
end

-- No Jump Cooldown Functions
local function applyNoJumpCooldown(character)
    if noJumpConnections[character] then return end
    local humanoid = character:WaitForChild("Humanoid")
    local conn = humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
        if humanoid.JumpPower ~= 55 then
            humanoid.JumpPower = 55
        end
    end)
    noJumpConnections[character] = conn
end

local function removeNoJumpCooldown(character)
    if noJumpConnections[character] then
        noJumpConnections[character]:Disconnect()
        noJumpConnections[character] = nil
    end
end

-- Anti Mod Helper
local function antiMod_CheckPlayer(player)
    for _, id in ipairs(antiModTargetUserIds) do
        if player.UserId == id then
            LP:Kick("A Moderator Joined")
            return
        end
    end
end

-- Bullet Rage TP Functions
local function GetRealWorldPos(OriginCF, TargetCF)
    local ActualOrigin = OriginCF * CFrame.new(0, -1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0)
    return ActualOrigin:ToObjectSpace(TargetCF):Inverse()
end

local function canShoot(char)
    if not char then return false end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then return false end
    local st = char:FindFirstChild("State")
    if not st then return false end
    local tool = char:FindFirstChildWhichIsA("Tool")
    if not tool or not tool:FindFirstChild("Handle") then return false end
    if not (tool:FindFirstChild("Ammo") or tool:FindFirstChild("Ammo_CLIENT")) then return false end
    if st:FindFirstChild("Down") and st.Down.Value then return false end
    if st:FindFirstChild("Carried") and st.Carried.Value ~= nil then return false end
    if char:FindFirstChild("CARRY_WELD") then return false end
    return true
end

local function getTargetPart(targetChar)
    if getgenv().BulletRageTP.ClosestPart then
        local best, mag = nil, math.huge
        local m = UserInputService:GetMouseLocation()
        for _,p in ipairs(targetChar:GetChildren()) do
            if p:IsA("BasePart") then
                local v,on = Camera:WorldToViewportPoint(p.Position)
                if on then
                    local d = (Vector2.new(v.X,v.Y)-m).Magnitude
                    if d < mag then best,mag = p,d end
                end
            end
        end
        return best
    end
    return targetChar:FindFirstChild("HumanoidRootPart") or targetChar:FindFirstChild("UpperTorso") or targetChar:FindFirstChild("Head")
end

local function findClosestValidTarget()
    local closest, minDist = nil, math.huge
    local myRoot = LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end

    for _, target in ipairs(Players:GetPlayers()) do
        if target ~= LP and isAlive(target) and isFullyLoaded(target) then
            local targetRoot = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
            if targetRoot then
                local dist = (targetRoot.Position - myRoot.Position).Magnitude
                if dist < minDist then
                    minDist, closest = dist, target
                end
            end
        end
    end
    return closest
end

local function doBulletTP(tool, targetPart)
    local char = LP.Character
    if not canShoot(char) then return end
    if not targetPart then return end

    local endpoint = targetPart.Position + (targetPart.AssemblyLinearVelocity or targetPart.Velocity) * getgenv().BulletRageTP.Prediction
    local offset = -Camera.CFrame.LookVector * 0.2
    local targetCF = CFrame.new(endpoint + offset, endpoint + Camera.CFrame.LookVector)
    local hand = (char and (char:FindFirstChild("RightHand") or char:FindFirstChild("Right Arm")))
    if not hand then return end

    local cfg = Configuration[tool.Name]
    local cd = rapidEnabled and 0.01 or (cfg and cfg.Cooldown and math.clamp(cfg.Cooldown * getgenv().BulletRageTP.SwapScale, getgenv().BulletRageTP.SwapMin, getgenv().BulletRageTP.SwapMax)) or 0.45
    if time() - lastSwapTime < cd then return end

    local saved = tool.Grip
    local new = GetRealWorldPos(hand.CFrame, targetCF)
    local backpack = LP:FindFirstChildOfClass("Backpack") or LP:FindFirstChild("Backpack")
    if not backpack then return end

    swapping = true
    tool.Parent = backpack
    tool.Grip = new
    tool.Parent = char
    lastSwapTime = time()

    RunService.Heartbeat:Wait()

    local handle = tool:FindFirstChild("Handle")
    local ammo = tool:FindFirstChild("Ammo_CLIENT")
    if ammo then ammo.Value = math.huge end

    local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent")
    if MainEvent then
        pcall(function()
            MainEvent:FireServer("Shoot", tool, handle.CFrame.LookVector * 1000)
        end)
    end

    pcall(function()
        Remote:FireServer("ShootingNoAmmo", tool)
    end)

    local startPos = handle.Position

    if tool.Name == "Double Barrel" then
        for i = 1, 4 do
            local spreadOffset = Vector3.new(
                math.random(-20, 20) / 100,
                math.random(-20, 20) / 100,
                math.random(-20, 20) / 100
            )
            local spreadTarget = targetPart.Position + spreadOffset
            GunHandler.Raycast(LP, startPos, spreadTarget, tool)
        end
    else
        GunHandler.Raycast(LP, startPos, targetPart.Position, tool)
    end

    RemoteFunction.InvokeClient(char, LP, "Aim", startPos)

    local restoreDelay = rapidEnabled and 0.01 or 0.05
    task.delay(restoreDelay, function()
        if tool and tool.Parent == char then
            tool.Parent = backpack
            tool.Grip = saved
            tool.Parent = char
        end
        swapping = false
    end)
end

-- ==================================================
-- ANTI STOMP LOOP (ORIGINAL CODE)
-- ==================================================
coroutine.wrap(function()
    while true do
        task.wait()
        if antiStompEnabled or autoAntiStomp or lagAntiStomp then
            local LocalCharacter = LP.Character
            local LocalRoot = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
            if LocalRoot then
                local OldVelocity = LocalRoot.AssemblyLinearVelocity
                LocalRoot.AssemblyLinearVelocity = Vector3.new(0, -9e10, 0)
                RunService.RenderStepped:Wait()
                LocalRoot.AssemblyLinearVelocity = OldVelocity
            end
        end
        RunService.Heartbeat:Wait()
    end
end)()

-- ==================================================
-- COMBAT TAB UI ELEMENTS
-- ==================================================

local CombatSection1 = CombatTab:CreateSection("Kill All & Rapid Fire")

local KillAllToggle = CombatTab:CreateToggle({
    Name = "Kill All",
    CurrentValue = false,
    Flag = "KillAllToggle",
    Callback = function(Value)
        killAllEnabled = Value
        StarterGui:SetCore("SendNotification", {Title = "Kill All", Text = Value and "Enabled" or "Disabled", Duration = 3})
    end,
})

local RapidFireToggle = CombatTab:CreateToggle({
    Name = "Rapid Fire All",
    CurrentValue = false,
    Flag = "RapidFireToggle",
    Callback = function(Value)
        allRapidEnabled = Value
        StarterGui:SetCore("SendNotification", {Title = "Rapid Fire All", Text = Value and "Enabled" or "Disabled", Duration = 3})
    end,
})

local BulletRageToggle = CombatTab:CreateToggle({
    Name = "Bullet Rage TP (Kill All Style)",
    CurrentValue = false,
    Flag = "BulletRageToggle",
    Callback = function(Value)
        rapidEnabled = Value
        StarterGui:SetCore("SendNotification", {Title = "Bullet Rage", Text = Value and "ON" or "OFF", Duration = 2})
    end,
})

local FireRateSlider = CombatTab:CreateSlider({
    Name = "Fire Rate (shots/sec)",
    Range = {1, 60},
    Increment = 1,
    Suffix = "",
    CurrentValue = 20,
    Flag = "FireRateSlider",
    Callback = function(Value)
        rapidFireRate = Value
        fireCooldown = 1 / Value
    end,
})

local KillAllFireRateSlider = CombatTab:CreateSlider({
    Name = "Kill All Fire Rate",
    Range = {0.01, 0.5},
    Increment = 0.01,
    Suffix = "s",
    CurrentValue = 0.05,
    Flag = "KillAllFireRateSlider",
    Callback = function(Value)
        fireCooldown = Value
    end,
})

local CircleRadiusSlider = CombatTab:CreateSlider({
    Name = "Circle Radius",
    Range = {5, 50},
    Increment = 1,
    Suffix = "studs",
    CurrentValue = 10,
    Flag = "CircleRadiusSlider",
    Callback = function(Value)
        radius = Value
    end,
})

local CircleSpeedSlider = CombatTab:CreateSlider({
    Name = "Circle Speed",
    Range = {0.01, 1},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = 0.1,
    Flag = "CircleSpeedSlider",
    Callback = function(Value)
        speed = Value
    end,
})

local BulletRagePredictionSlider = CombatTab:CreateSlider({
    Name = "Bullet Rage Prediction",
    Range = {0, 0.5},
    Increment = 0.01,
    Suffix = "s",
    CurrentValue = 0.14,
    Flag = "BulletRagePredictionSlider",
    Callback = function(Value)
        getgenv().BulletRageTP.Prediction = Value
    end,
})

local BulletRageFireRateSlider = CombatTab:CreateSlider({
    Name = "Bullet Rage Fire Rate",
    Range = {0.05, 1.0},
    Increment = 0.01,
    Suffix = "s",
    CurrentValue = 0.22,
    Flag = "BulletRageFireRateSlider",
    Callback = function(Value)
        FIRE_COOLDOWN = Value
    end,
})

local CombatSection2 = CombatTab:CreateSection("Gun Modifications")

local InfAmmoToggle = CombatTab:CreateToggle({
    Name = "Inf Ammo",
    CurrentValue = false,
    Flag = "InfAmmoToggle",
    Callback = function(Value)
        if Value then
            enableInfAmmo()
            StarterGui:SetCore("SendNotification", {Title = "Inf Ammo", Text = "Enabled", Duration = 3})
        else
            disableInfAmmo()
            StarterGui:SetCore("SendNotification", {Title = "Inf Ammo", Text = "Disabled", Duration = 3})
        end
    end,
})

local NoShootingCooldownToggle = CombatTab:CreateToggle({
    Name = "No Shooting Cooldown",
    CurrentValue = true,
    Flag = "NoShootingCooldownToggle",
    Callback = function(Value)
        noShootingCooldownEnabled = Value
        applyGunConfig()
        StarterGui:SetCore("SendNotification", {Title = "No Shooting Cooldown", Text = Value and "Enabled" or "Disabled", Duration = 3})
    end,
})

local NoWalkCooldownToggle = CombatTab:CreateToggle({
    Name = "No Walk Cooldown When Shooting",
    CurrentValue = true,
    Flag = "NoWalkCooldownToggle",
    Callback = function(Value)
        noWalkCooldownEnabled = Value
        applyGunConfig()
        StarterGui:SetCore("SendNotification", {Title = "No Walk Cooldown When Shooting", Text = Value and "Enabled" or "Disabled", Duration = 3})
    end,
})

local NoJumpCooldownToggle = CombatTab:CreateToggle({
    Name = "No Jump Cooldown",
    CurrentValue = false,
    Flag = "NoJumpCooldownToggle",
    Callback = function(Value)
        noJumpCooldownEnabled = Value
        local char = LP.Character
        if char then
            if noJumpCooldownEnabled then
                applyNoJumpCooldown(char)
            else
                removeNoJumpCooldown(char)
            end
        end
        StarterGui:SetCore("SendNotification", {Title = "No Jump Cooldown", Text = Value and "Enabled" or "Disabled", Duration = 3})
    end,
})

local CombatSection3 = CombatTab:CreateSection("Defensive")

local AntiStompToggle = CombatTab:CreateToggle({
    Name = "Anti Stomp",
    CurrentValue = false,
    Flag = "AntiStompToggle",
    Callback = function(Value)
        antiStompEnabled = Value
        StarterGui:SetCore("SendNotification", {Title = "Anti Stomp", Text = Value and "Enabled" or "Disabled", Duration = 3})
    end,
})

local AntiModToggle = CombatTab:CreateToggle({
    Name = "Anti Mod",
    CurrentValue = false,
    Flag = "AntiModToggle",
    Callback = function(Value)
        antiModEnabled = Value
        if antiModEnabled then
            for _, player in ipairs(Players:GetPlayers()) do
                antiMod_CheckPlayer(player)
            end
            antiModConnection = Players.PlayerAdded:Connect(antiMod_CheckPlayer)
        elseif antiModConnection then
            antiModConnection:Disconnect()
            antiModConnection = nil
        end
        StarterGui:SetCore("SendNotification", {Title = "Anti Mod", Text = Value and "Enabled" or "Disabled", Duration = 3})
    end,
})

local CombatSection4 = CombatTab:CreateSection("Target Lists")

local TargetOnlyInput = CombatTab:CreateInput({
    Name = "Add to Target Only (Kill All)",
    PlaceholderText = "Username",
    RemoveTextAfterFocusLost = true,
    Callback = function(Text)
        if Text ~= "" then
            table.insert(targetOnlyList, Text:lower())
            StarterGui:SetCore("SendNotification", {Title = "Target Only", Text = "Added: " .. Text, Duration = 3})
        end
    end,
})

local DoNotTargetInput = CombatTab:CreateInput({
    Name = "Add to Do Not Target (Kill All)",
    PlaceholderText = "Username",
    RemoveTextAfterFocusLost = true,
    Callback = function(Text)
        if Text ~= "" then
            table.insert(doNotTargetList, Text:lower())
            StarterGui:SetCore("SendNotification", {Title = "Do Not Target", Text = "Added: " .. Text, Duration = 3})
        end
    end,
})

local WhitelistInput = CombatTab:CreateInput({
    Name = "Add to Whitelist (Rapid Fire Protect)",
    PlaceholderText = "Username",
    RemoveTextAfterFocusLost = true,
    Callback = function(Text)
        if Text ~= "" then
            table.insert(whitelist, Text:lower())
            StarterGui:SetCore("SendNotification", {Title = "Whitelist", Text = "Added: " .. Text, Duration = 3})
        end
    end,
})

local BlacklistInput = CombatTab:CreateInput({
    Name = "Add to Blacklist (Rapid Fire Target Only)",
    PlaceholderText = "Username",
    RemoveTextAfterFocusLost = true,
    Callback = function(Text)
        if Text ~= "" then
            table.insert(rapidBlacklist, Text:lower())
            StarterGui:SetCore("SendNotification", {Title = "Blacklist", Text = "Added: " .. Text, Duration = 3})
        end
    end,
})

local ClearListsButton = CombatTab:CreateButton({
    Name = "Clear All Lists",
    Callback = function()
        targetOnlyList = {}
        doNotTargetList = {}
        whitelist = {}
        rapidBlacklist = {}
        StarterGui:SetCore("SendNotification", {Title = "Lists Cleared", Text = "All lists cleared", Duration = 3})
    end,
})

-- ==================================================
-- COMBAT LOOPS
-- ==================================================

-- Main Combat Loop
RunService.RenderStepped:Connect(function(delta)
    if not Root then return end

    -- Kill All Logic
    if killAllEnabled then
        local livingTargets = {}
        for _, target in ipairs(Players:GetPlayers()) do
            if shouldTargetPlayer(target) and isAlive(target) then
                table.insert(livingTargets, target)
            end
        end

        if #livingTargets > 0 then
            local tool = LP.Character and LP.Character:FindFirstChildOfClass("Tool")
            if tool then
                if not currentKillAllTarget or not isAlive(currentKillAllTarget) then
                    currentKillAllTarget = getClosestKillAllTarget(livingTargets)
                end
                if currentKillAllTarget and isAlive(currentKillAllTarget) then
                    CircleAroundTarget(currentKillAllTarget)
                    lastFire = lastFire + delta
                    if lastFire >= fireCooldown then
                        lastFire = 0
                        ForceHit(tool, currentKillAllTarget)
                    end
                end
            end
        else
            currentKillAllTarget = nil
            local downedTargets = {}
            for _, target in ipairs(Players:GetPlayers()) do
                if shouldTargetPlayer(target) and isDowned(target) and not isDead(target) then
                    table.insert(downedTargets, target)
                end
            end
            StompTarget(downedTargets)
        end
    end

    -- Rapid Fire Logic
    if allRapidEnabled then
        local tool = LP.Character and LP.Character:FindFirstChildOfClass("Tool")
        if tool then
            for _, target in ipairs(Players:GetPlayers()) do
                if target ~= LP and isAlive(target) and isFullyLoaded(target) then
                    local nameLower = target.Name:lower()
                    local displayLower = target.DisplayName:lower()
                    local skip = false
                    for _, name in ipairs(whitelist) do
                        if nameLower:find(name) or displayLower:find(name) then
                            skip = true
                            break
                        end
                    end
                    if not skip then
                        if #rapidBlacklist > 0 then
                            local isInBlacklist = false
                            for _, name in ipairs(rapidBlacklist) do
                                if nameLower:find(name) or displayLower:find(name) then
                                    isInBlacklist = true
                                    break
                                end
                            end
                            if not isInBlacklist then skip = true end
                        end
                    end
                    if skip then continue end
                    if not lastFiresAll[target] then lastFiresAll[target] = 0 end
                    lastFiresAll[target] = lastFiresAll[target] + delta
                    if lastFiresAll[target] >= (1 / rapidFireRate) then
                        lastFiresAll[target] = 0
                        ShootAtTarget(tool, target)
                    end
                end
            end
        end
    end
end)

-- Bullet Rage TP Loop
RunService.RenderStepped:Connect(function(delta)
    if not rapidEnabled or not LP.Character then return end

    local tool = LP.Character:FindFirstChildOfClass("Tool")
    if not tool or not tool:FindFirstChild("Ammo_CLIENT") then return end

    local now = time()
    currentTarget = findClosestValidTarget()

    if not currentTarget then return end

    if currentTarget and not swapping and (now - lastFireTime >= FIRE_COOLDOWN) then
        lastFireTime = now
        
        local targetChar = currentTarget.Character
        if targetChar and isAlive(currentTarget) and isFullyLoaded(currentTarget) then
            local targetPart = getTargetPart(targetChar)
            if targetPart then
                pcall(doBulletTP, tool, targetPart)
            end
        end

        if not isAlive(currentTarget) then
            currentTarget = nil
        end
    end
end)

-- Handle Character Added
LP.CharacterAdded:Connect(function(char)
    Root = char:WaitForChild("HumanoidRootPart", 10)
    if noJumpCooldownEnabled then
        applyNoJumpCooldown(char)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    lastFiresAll[player] = nil
end)

-- Initial Setup
if LP.Character then
    Root = LP.Character:FindFirstChild("HumanoidRootPart")
    if noJumpCooldownEnabled then
        applyNoJumpCooldown(LP.Character)
    end
end

-- ==================================================
-- INDEX-STYLE AIMBOT SECTION (ORIGINAL)
-- ==================================================
local AimbotSection = MainTab:CreateSection("Index-Style Aimbot")

local AimbotToggle = MainTab:CreateToggle({
    Name = "Enable Index-Style Aimbot",
    CurrentValue = false,
    Flag = "IndexStyleAimbot",
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Aimbot",
            Content = "Aimbot " .. (Value and "Enabled" or "Disabled"),
            Duration = 2
        })
    end
})

local AimbotLockButton = MainTab:CreateButton({
    Name = "Lock/Unlock Target",
    Callback = function()
        if not AimbotToggle.CurrentValue then
            Rayfield:Notify({Title = "Aimbot", Content = "Aimbot is disabled. Enable it to lock targets.", Duration = 2})
            return
        end

        if not indexLockedTarget then
            -- Acquire closest visible player to cursor
            local best, bestDist = nil, math.huge
            local mousePos = UserInputService:GetMouseLocation()
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= LP and isAliveAimbot(plr) and plr.Character then
                    local partName = AimbotTargetPartDropdown.CurrentOption[1]
                    local part = plr.Character:FindFirstChild(partName)
                    if part then
                        local pos, visible = Camera:WorldToViewportPoint(part.Position)
                        if visible then
                            local d = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude
                            if d < bestDist then
                                bestDist = d
                                best = plr
                            end
                        end
                    end
                end
            end
            indexLockedTarget = best
            if best then
                Rayfield:Notify({Title = "Aimbot", Content = "Locked onto " .. best.Name, Duration = 2})
            else
                Rayfield:Notify({Title = "Aimbot", Content = "No player found to lock", Duration = 2})
            end
        else
            Rayfield:Notify({
                Title = "Aimbot",
                Content = "Unlocked target " .. indexLockedTarget.Name,
                Duration = 2
            })
            indexLockedTarget = nil
        end
    end,
})

local AimbotSmoothnessSlider = MainTab:CreateSlider({
    Name = "Smoothness",
    Range = {1, 10},
    Increment = 1,
    CurrentValue = 1,
    Flag = "IndexAimbotSmooth",
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Aimbot",
            Content = "Smoothness set to " .. Value,
            Duration = 2
        })
    end
})

local AimbotPredictionSlider = MainTab:CreateSlider({
    Name = "Prediction",
    Range = {0, 0.5},
    Increment = 0.01,
    CurrentValue = 0.12,
    Flag = "IndexAimbotPred",
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Aimbot",
            Content = "Prediction set to " .. Value,
            Duration = 2
        })
    end
})

local AimbotTargetPartDropdown = MainTab:CreateDropdown({
    Name = "Target Part",
    Options = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    CurrentOption = {"HumanoidRootPart"},
    Flag = "IndexAimbotPart",
    Callback = function(Option)
        Rayfield:Notify({
            Title = "Aimbot",
            Content = "Target part set to " .. Option,
            Duration = 2
        })
    end
})

-- ==================================================
-- SILENT AIM SECTION (ORIGINAL)
-- ==================================================
local SilentAimSection = MainTab:CreateSection("Silent Aim")

local SilentAimToggle = MainTab:CreateToggle({
    Name = "Enable Silent Aim",
    CurrentValue = false,
    Flag = "SA_Enabled",
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "Silent Aim " .. (Value and "Enabled" or "Disabled"),
            Duration = 2
        })
    end
})

local SATypeDropdown = MainTab:CreateDropdown({
    Name = "Type",
    Options = {"FOV", "Target"},
    CurrentOption = {"FOV"},
    Flag = "SA_Type",
    Callback = function(Option)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "Type set to " .. Option,
            Duration = 2
        })
    end
})

local SAPartDropdown = MainTab:CreateDropdown({
    Name = "Part",
    Options = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    CurrentOption = {"Head"},
    Flag = "SA_Part",
    Callback = function(Option)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "Part set to " .. Option,
            Duration = 2
        })
    end
})

local SAPredictionSlider = MainTab:CreateSlider({
    Name = "Prediction",
    Range = {0, 0.5},
    Increment = 0.01,
    CurrentValue = 0.12,
    Flag = "SA_Pred",
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "Prediction set to " .. Value,
            Duration = 2
        })
    end
})

local SALockButton = MainTab:CreateButton({
    Name = "Lock/Unlock Target (Silent Aim)",
    Callback = function()
        if not SilentAimToggle.CurrentValue then
            Rayfield:Notify({Title = "Silent Aim", Content = "Enable Silent Aim to lock targets.", Duration = 2})
            return
        end
        if SATypeDropdown.CurrentOption[1] ~= "Target" then
            Rayfield:Notify({Title = "Silent Aim", Content = "Set Type to 'Target' to use lock-on.", Duration = 2})
            return
        end

        if saLockedTarget then
            Rayfield:Notify({Title = "Silent Aim", Content = "Unlocked target " .. saLockedTarget.Name, Duration = 2})
            saLockedTarget = nil
        else
            local t = saGetClosestByFOV()
            if t then
                saLockedTarget = t
                Rayfield:Notify({Title = "Silent Aim", Content = "Locked onto " .. t.Name, Duration = 2})
            else
                Rayfield:Notify({Title = "Silent Aim", Content = "No target in FOV", Duration = 2})
            end
        end
    end,
})




-- Silent Aim Visuals Sub-Section
local SAVisualsSection = MainTab:CreateSection("Silent Aim Visuals")

local SAShowFOVToggle = MainTab:CreateToggle({
    Name = "Show FOV",
    CurrentValue = false,
    Flag = "SA_ShowFOV",
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "Show FOV " .. (Value and "Enabled" or "Disabled"),
            Duration = 2
        })
    end
})

local SAFillFOVToggle = MainTab:CreateToggle({
    Name = "Filled FOV",
    CurrentValue = false,
    Flag = "SA_FillFOV",
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "Filled FOV " .. (Value and "Enabled" or "Disabled"),
            Duration = 2
        })
    end
})

local SAFOVRadiusSlider = MainTab:CreateSlider({
    Name = "FOV Radius",
    Range = {10, 600},
    Increment = 10,
    CurrentValue = 120,
    Flag = "SA_FOVRad",
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "FOV Radius set to " .. Value,
            Duration = 2
        })
    end
})

local SAFOVThicknessSlider = MainTab:CreateSlider({
    Name = "FOV Thickness",
    Range = {1, 5},
    Increment = 1,
    CurrentValue = 2,
    Flag = "SA_FOVThk",
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "FOV Thickness set to " .. Value,
            Duration = 2
        })
    end
})

local SAFOVTransparencySlider = MainTab:CreateSlider({
    Name = "FOV Transparency",
    Range = {0, 1},
    Increment = 0.1,
    CurrentValue = 1,
    Flag = "SA_FOVAlpha",
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "FOV Transparency set to " .. Value,
            Duration = 2
        })
    end
})

local SAFOVColorPicker = MainTab:CreateColorPicker({
    Name = "FOV Color",
    Color = Color3.fromRGB(255, 255, 255),
    Flag = "SA_FOVColor",
    Callback = function(Color)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "FOV Color updated",
            Duration = 2
        })
    end
})

local SAShowTracerToggle = MainTab:CreateToggle({
    Name = "Show Tracer",
    CurrentValue = false,
    Flag = "SA_ShowTracer",
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "Show Tracer " .. (Value and "Enabled" or "Disabled"),
            Duration = 2
        })
    end
})

local SATracerThicknessSlider = MainTab:CreateSlider({
    Name = "Tracer Thickness",
    Range = {1, 5},
    Increment = 1,
    CurrentValue = 2,
    Flag = "SA_TrThk",
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "Tracer Thickness set to " .. Value,
            Duration = 2
        })
    end
})

local SATracerTransparencySlider = MainTab:CreateSlider({
    Name = "Tracer Transparency",
    Range = {0, 1},
    Increment = 0.1,
    CurrentValue = 1,
    Flag = "SA_TrAlpha",
    Callback = function(Value)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "Tracer Transparency set to " .. Value,
            Duration = 2
        })
    end
})

local SATracerColorPicker = MainTab:CreateColorPicker({
    Name = "Tracer Color",
    Color = Color3.fromRGB(255, 255, 255),
    Flag = "SA_TrColor",
    Callback = function(Color)
        Rayfield:Notify({
            Title = "Silent Aim",
            Content = "Tracer Color updated",
            Duration = 2
        })
    end
})

-- Menu Section
local UnloadButton = MenuTab:CreateButton({
    Name = "Unload",
    Callback = function()
        Rayfield:Destroy()
    end
})

-- ==================================================
-- AIMBOT LOGIC (ORIGINAL)
-- ==================================================


local indexLockedTarget = nil

-- Helper function: Check if player is alive for aimbot
local function isAliveAimbot(plr)
    local success, result = pcall(function()
        local c = plr and plr.Character
        local h = c and c:FindFirstChildOfClass("Humanoid")
        if not h or h.Health <= 0 then return false end
        local st = c and c:FindFirstChild("State")
        if st and st:FindFirstChild("Down") and st.Down.Value then return false end
        if c and c:FindFirstChild("ForceField") then return false end
        return true
    end)
    if not success then
        Rayfield:Notify({
            Title = "Aimbot Error",
            Content = "Failed to check player status: " .. result,
            Duration = 3
        })
        return false
    end
    return result
end

-- Aimbot runtime loop
local function index_RunAimbot()
    if not AimbotToggle.CurrentValue then return end
    local target = indexLockedTarget
    if not target or not isAliveAimbot(target) or not target.Character then
        indexLockedTarget = nil
        return
    end

    local partName = AimbotTargetPartDropdown.CurrentOption[1]
    local part = target.Character:FindFirstChild(partName)
    if not part then
        Rayfield:Notify({
            Title = "Aimbot Error",
            Content = "Target part " .. partName .. " not found on " .. target.Name,
            Duration = 2
        })
        indexLockedTarget = nil
        return
    end

    local success, result = pcall(function()
        local pred = AimbotPredictionSlider.CurrentValue or 0
        local smooth = AimbotSmoothnessSlider.CurrentValue or 1
        local endPos = part.Position + part.Velocity * pred
        local newCF = CFrame.new(Camera.CFrame.Position, endPos)
        Camera.CFrame = Camera.CFrame:Lerp(newCF, 1 / smooth)
    end)
    if not success then
        Rayfield:Notify({
            Title = "Aimbot Error",
            Content = "Failed to update camera: " .. result,
            Duration = 3
        })
    end
end

RunService.RenderStepped:Connect(index_RunAimbot)

-- ==================================================
-- SILENT AIM LOGIC (ORIGINAL)
-- ==================================================
local saLockedTarget = nil

-- Drawing Objects for Silent Aim
local saCircle = Drawing.new("Circle")
saCircle.NumSides = 128
saCircle.Filled = false
saCircle.Visible = false

local saTracer = Drawing.new("Line")
saTracer.Visible = false

-- Cached player list for Silent Aim (shared)
local cachedPlayers = Players:GetPlayers()
Players.PlayerAdded:Connect(function(plr)
    table.insert(cachedPlayers, plr)
end)
Players.PlayerRemoving:Connect(function(plr)
    for i, p in ipairs(cachedPlayers) do
        if p == plr then
            table.remove(cachedPlayers, i)
            break
        end
    end
end)

-- Helper function: Check if player is valid for Silent Aim
local function saIsValid(plr)
    if not plr or plr == LP then return false end
    local char = plr.Character
    if not char then return false end
    local h = char:FindFirstChildOfClass("Humanoid")
    if not h or h.Health <= 0 then return false end
    local st = char:FindFirstChild("State")
    if st and st:FindFirstChild("Down") and st.Down.Value then return false end
    if char:FindFirstChild("ForceField") then return false end
    return true
end

-- Get part for Silent Aim
local function saGetPart(plr)
    local char = plr.Character
    if not char then return end
    local partName = SAPartDropdown.CurrentOption[1]
    return char:FindFirstChild(partName) or char:FindFirstChild("HumanoidRootPart")
end

-- Get closest by FOV for Silent Aim
local function saGetClosestByFOV()
    local best, bestMag = nil, math.huge
    local mousePos = UserInputService:GetMouseLocation()
    for _, plr in ipairs(cachedPlayers) do
        if saIsValid(plr) then
            local part = saGetPart(plr)
            if part then
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local mag = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude
                    if mag < bestMag and mag <= SAFOVRadiusSlider.CurrentValue then
                        best, bestMag = plr, mag
                    end
                end
            end
        end
    end
    return best
end

-- Get target for Silent Aim
local function saGetTarget()
    if SATypeDropdown.CurrentOption[1] == "Target" then
        if saLockedTarget and saIsValid(saLockedTarget) then return saLockedTarget end
        return nil
    else
        return saGetClosestByFOV()
    end
end

-- Get aim position for Silent Aim
local function saGetAimPosition(plr)
    if not plr then return nil end
    local part = saGetPart(plr)
    if not part then return nil end
    local vel = part.Velocity or Vector3.zero
    return part.Position + vel * SAPredictionSlider.CurrentValue
end

-- Mouse.Hit/Target hijack for Silent Aim
local oldIndex
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if not checkcaller() and SilentAimToggle.CurrentValue and self == Mouse then
        if key == "Hit" then
            local t = saGetTarget()
            local pos = t and saGetAimPosition(t)
            if pos then
                return CFrame.new(pos)
            end
        elseif key == "Target" then
            local t = saGetTarget()
            local part = t and saGetPart(t)
            if part then
                return part
            end
        end
    end
    return oldIndex(self, key)
end))

-- Optimized Visuals Loop for Silent Aim (with frame skip)
local frameCounter = 0
local skipFrames = 2 -- Update visuals every 2 frames
RunService.RenderStepped:Connect(function()
    if not SilentAimToggle.CurrentValue then
        saCircle.Visible = false
        saTracer.Visible = false
        return
    end

    local mouseLoc = UserInputService:GetMouseLocation()
    local target = saGetTarget()
    local part = target and saGetPart(target)

    frameCounter = frameCounter + 1
    if frameCounter % skipFrames ~= 0 then return end

    -- Update FOV Circle
    if SAShowFOVToggle.CurrentValue then
        saCircle.Position = mouseLoc
        saCircle.Radius = SAFOVRadiusSlider.CurrentValue
        saCircle.Thickness = SAFOVThicknessSlider.CurrentValue
        saCircle.Transparency = SAFOVTransparencySlider.CurrentValue
        saCircle.Filled = SAFillFOVToggle.CurrentValue
        saCircle.Color = SAFOVColorPicker.Color
        saCircle.Visible = true
    else
        saCircle.Visible = false
    end

    -- Update Tracer
    if SAShowTracerToggle.CurrentValue and part then
        local pos, onScreen = Camera:WorldToViewportPoint(part.Position)
        if onScreen then
            saTracer.From = mouseLoc
            saTracer.To = Vector2.new(pos.X, pos.Y)
            saTracer.Thickness = SATracerThicknessSlider.CurrentValue
            saTracer.Transparency = SATracerTransparencySlider.CurrentValue
            saTracer.Color = SATracerColorPicker.Color
            saTracer.Visible = true
        else
            saTracer.Visible = false
        end
    else
        saTracer.Visible = false
    end
end)

-- ==================================================
-- SHOP FEATURES
-- ==================================================

-- Shop Variables
local autoArmorEnabled = false
local autoArmorOnDamage = false
local armorCooldown = false
local armorPurchaseCooldown = 2
local lastArmorPurchase = 0
local healthThreshold = 50
local autoRefreshEnabled = false
local autoRefreshConnection = nil

local shields = {
    ["High medium shield 1"] = {index = 44},
    ["High medium shield 2"] = {name = "High-Medium Shield"},
    ["High medium shield 3"] = {index = 46},
    ["Medium Shield 1"] = {name = "Medium Shield"},
    ["Medium Shield 2"] = {index = 10},
    ["Medium Shield 3"] = {index = 35},
    ["Medium Shield 4"] = {index = 9},
    ["Medium Shield 5"] = {index = 41},
    ["Medium Shield 6"] = {index = 15},
    ["Medium Shield 7"] = {index = 47},
}

local foods = {
    ["Chicken"] = {index = 30},
    ["Hamburger"] = {index = 48},
    ["Pizza"] = {index = 25},
    ["Taco"] = {index = 49},
}

local shieldTargets = {}

local shieldKeys = {}
for k, _ in pairs(shields) do
    table.insert(shieldKeys, k)
end
table.sort(shieldKeys)

local foodKeys = {"Chicken", "Hamburger", "Pizza", "Taco"}

local defaultShield = "High medium shield 3"

local function notifyShop(msg, duration)
    StarterGui:SetCore("SendNotification", {Title = "Valyrian Shop", Text = msg, Duration = duration or 3})
end

local function refreshShields()
    if not Workspace:FindFirstChild("Blacklisted") or not Workspace.Blacklisted:FindFirstChild("Bought") then return end
    local bought = Workspace.Blacklisted.Bought
    for shieldName, info in pairs(shields) do
        local target
        if info.name then
            target = bought:FindFirstChild(info.name)
        elseif info.index then
            local children = bought:GetChildren()
            if #children >= info.index then
                target = children[info.index]
            end
        end
        shieldTargets[shieldName] = target
    end

    -- Refresh food targets
    for foodName, info in pairs(foods) do
        local target
        if info.index then
            local children = bought:GetChildren()
            if #children >= info.index then
                target = children[info.index]
            end
        end
        shieldTargets[foodName] = target -- Reuse shieldTargets for simplicity
    end
end

local function purchaseArmor()
    if armorCooldown then return end
    armorCooldown = true
    
    local targetShield = shieldTargets[defaultShield]
    if not targetShield then
        notifyShop(defaultShield .. " not found!")
        armorCooldown = false
        return
    end
    
    local targetPos
    if targetShield:IsA("BasePart") then
        targetPos = targetShield.Position + Vector3.new(0, 3, 0)
    else
        local primary = targetShield.PrimaryPart or targetShield:FindFirstChild("HumanoidRootPart") or targetShield:FindFirstChildOfClass("BasePart")
        if primary then
            targetPos = primary.Position + Vector3.new(0, 3, 0)
        else
            notifyShop(defaultShield .. " has no valid position!")
            armorCooldown = false
            return
        end
    end
    
    if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
        local currentPos = LP.Character.HumanoidRootPart.Position
        
        LP.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos)
        notifyShop("Purchasing " .. defaultShield .. "...", 2)
        
        task.wait(0.3)
        
        local clickDetector = targetShield:FindFirstChildOfClass("ClickDetector")
        if clickDetector then
            fireclickdetector(clickDetector)
            notifyShop("Auto-purchased " .. defaultShield .. "!", 3)
        else
            for _, child in ipairs(targetShield:GetDescendants()) do
                if child:IsA("ClickDetector") then
                    fireclickdetector(child)
                    notifyShop("Auto-purchased " .. defaultShield .. "!", 3)
                    break
                end
            end
        end
        
        task.wait(0.5)
        if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
            LP.Character.HumanoidRootPart.CFrame = CFrame.new(currentPos)
        end
        
        lastArmorPurchase = tick()
        task.wait(armorPurchaseCooldown)
        armorCooldown = false
    else
        notifyShop("Character not loaded!")
        armorCooldown = false
    end
end

local function teleportAndPurchaseItem(shieldName)
    local target = shieldTargets[shieldName]
    if target then
        local targetPos
        if target:IsA("BasePart") then
            targetPos = target.Position + Vector3.new(0, 3, 0)
        else
            local primary = target.PrimaryPart or target:FindFirstChild("HumanoidRootPart") or target:FindFirstChildOfClass("BasePart")
            if primary then
                targetPos = primary.Position + Vector3.new(0, 3, 0)
            else
                notifyShop(shieldName .. " has no valid position!")
                return
            end
        end
        
        if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
            local currentPos = LP.Character.HumanoidRootPart.Position
            
            LP.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos)
            notifyShop("Teleporting to " .. shieldName .. "...", 2)
            
            task.wait(0.3)
            
            local clickDetector = target:FindFirstChildOfClass("ClickDetector")
            if clickDetector then
                fireclickdetector(clickDetector)
                notifyShop("Auto-purchased " .. shieldName .. "!", 3)
            else
                for _, child in ipairs(target:GetDescendants()) do
                    if child:IsA("ClickDetector") then
                        fireclickdetector(child)
                        notifyShop("Auto-purchased " .. shieldName .. "!", 3)
                        break
                    end
                end
            end
            
            task.wait(0.5)
            if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
                LP.Character.HumanoidRootPart.CFrame = CFrame.new(currentPos)
            end
        else
            notifyShop("Character not loaded!")
        end
    else
        notifyShop(shieldName .. " not found! Refreshing...", 3)
        refreshShields()
    end
end

local function checkShopHealth()
    local character = LP.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    local currentHealth = humanoid.Health
    local maxHealth = humanoid.MaxHealth
    local healthPercent = (currentHealth / maxHealth) * 100
    
    if autoArmorOnDamage and healthPercent < healthThreshold and humanoid.MaxHealth == 100 and (tick() - lastArmorPurchase) > armorPurchaseCooldown and not armorCooldown then
        purchaseArmor()
    end
end

task.spawn(function()
    while true do
        task.wait(1)
        checkShopHealth()
    end
end)

task.spawn(function()
    repeat task.wait() until Workspace:FindFirstChild("Blacklisted") and Workspace.Blacklisted:FindFirstChild("Bought")
    refreshShields()
    Workspace.Blacklisted.Bought.ChildAdded:Connect(function()
        task.wait(0.1)
        refreshShields()
    end)
    Workspace.Blacklisted.Bought.ChildRemoved:Connect(function()
        task.wait(0.1)
        refreshShields()
    end)
end)

if LP.Character then
    refreshShields()
end

-- Shop UI Setup
local ShopControlsSection = ShopTab:CreateSection("Shop Controls")

local AutoArmorToggle = ShopTab:CreateToggle({
    Name = "Auto Re-Armor on Respawn",
    CurrentValue = false,
    Flag = "AutoArmorToggle",
    Callback = function(Value)
        autoArmorEnabled = Value
        notifyShop("Auto Re-Armor on Respawn " .. (Value and "Enabled" or "Disabled"), 2)
    end,
})

local AutoArmorDamageToggle = ShopTab:CreateToggle({
    Name = "Auto Armor on Low Health",
    CurrentValue = false,
    Flag = "AutoArmorDamageToggle",
    Callback = function(Value)
        autoArmorOnDamage = Value
        notifyShop("Auto Armor on Low Health " .. (Value and "Enabled" or "Disabled"), 2)
    end,
})

local ShopHealthThresholdSlider = ShopTab:CreateSlider({
    Name = "Health % for Auto Armor",
    Range = {10, 90},
    Increment = 1,
    Suffix = "%",
    CurrentValue = 50,
    Flag = "ShopHealthThresholdSlider",
    Callback = function(Value)
        healthThreshold = Value
    end,
})

local DefaultArmorDropdown = ShopTab:CreateDropdown({
    Name = "Default Auto Armor",
    Options = shieldKeys,
    CurrentOption = {"High medium shield 3"},
    Flag = "DefaultArmorDropdown",
    Callback = function(Option)
        defaultShield = Option[1]
    end,
})

local ShieldsSection = ShopTab:CreateSection("Shields")

for _, shieldName in ipairs(shieldKeys) do
    ShopTab:CreateButton({
        Name = shieldName,
        Callback = function()
            teleportAndPurchaseItem(shieldName)
        end,
    })
end

local FoodSection = ShopTab:CreateSection("Food Section")

for _, foodName in ipairs(foodKeys) do
    ShopTab:CreateButton({
        Name = foodName,
        Callback = function()
            teleportAndPurchaseItem(foodName)
        end,
    })
end

local AutoRefreshToggle = ShopTab:CreateToggle({
    Name = "Auto Refresh Shop Locations",
    CurrentValue = false,
    Flag = "AutoRefreshToggle",
    Callback = function(Value)
        autoRefreshEnabled = Value
        if Value and not autoRefreshConnection then
            autoRefreshConnection = task.spawn(function()
                while autoRefreshEnabled do
                    task.wait(5)
                    refreshShields()
                    notifyShop("Shop items refreshed!", 2)
                end
            end)
        end
        notifyShop("Auto Refresh Shop Locations " .. (Value and "Enabled" or "Disabled"), 2)
    end,
})

-- Handle Character Added for Auto Armor on Respawn
LP.CharacterAdded:Connect(function(char)
    task.wait(2)
    refreshShields()
    
    if autoArmorEnabled then
        task.wait(2)
        purchaseArmor()
    end
end)

-- Initial notification
Rayfield:Notify({
    Title = "Complete System Loaded",
    Content = "Aimbot, Silent Aim, Combat & Desync Features Loaded",
    Duration = 5
})

Rayfield:Notify({
   Title = "Valyrian Standalone Shop Loaded",
   Content = "Shop features including auto armor, manual purchases, and auto refresh are ready.",
   Duration = 5,
   Image = 4483362458,
   Actions = {},
})
